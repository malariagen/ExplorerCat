package net.explorercat.cql.selection.query.translators.mysql;

import java.util.ArrayList;
import java.util.List;

import net.explorercat.cql.expressions.Expression;
import net.explorercat.cql.expressions.ExpressionType;
import net.explorercat.cql.expressions.special.RangeExpression;
import net.explorercat.cql.expressions.unary.ArrayAccessExpression;
import net.explorercat.cql.expressions.values.ReferenceExpression;
import net.explorercat.util.exceptions.ExplorerCatCheckedException;
import net.explorercat.util.exceptions.TranslationException;

/**
 * Translates expressions into MySQL code (in the form of prepared statements)
 * that can be executed against a DB. Each type of expression has a translator
 * implemented by a inner class.
 * 
 * This was an ideal candidate for implementing the visitor pattern but we opted
 * for exploring the expression tree externally.
 * 
 * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
 * @date 4 Mar 2011
 */

public class ExpressionTranslatorMySQL
{
    // Binary translators.
    private BinaryExpressionTranslator binaryTranslator;
    private ConcatenationExpressionTranslator concatenationTranslator;
    private MatchesExpressionTranslator matchesStringTranslator;
    private StartsWithExpressionTranslatorMySQL startsWithTranslator;
    private PowerExpressionTranslator powerTranslator;

    // Special translators.
    private RangeExpressionTranslator rangeTranslator;

    // Unary translators.
    private UnaryExpressionTranslator unaryTranslator;
    private StatsExpressionTranslator statsTranslator;

    // Value translators.
    private LiteralExpressionTranslator literatlTranslator;
    private ReferenceExpressionTranslator referenceTranslator;
    private VariableExpressionTranslator variableTranslator;

    /**
     * Builds a expression translator for MySQL. The constructor initialises all
     * the internal translators used by the class. It is a good idea to reuse it
     * instead of creating a new translator each time.
     */

    public ExpressionTranslatorMySQL()
    {
	this.binaryTranslator = new BinaryExpressionTranslator();
	this.concatenationTranslator = new ConcatenationExpressionTranslator();
	this.matchesStringTranslator = new MatchesExpressionTranslator();
	this.startsWithTranslator = new StartsWithExpressionTranslatorMySQL();
	this.powerTranslator = new PowerExpressionTranslator();

	this.rangeTranslator = new RangeExpressionTranslator();
	this.unaryTranslator = new UnaryExpressionTranslator();
	this.statsTranslator = new StatsExpressionTranslator();

	this.literatlTranslator = new LiteralExpressionTranslator();
	this.referenceTranslator = new ReferenceExpressionTranslator();
	this.variableTranslator = new VariableExpressionTranslator();
    }

    /**
     * Translates the given expression into MySQL code that can be executed as a
     * prepared statement.
     * 
     * @param expression The expression to be translated.
     * @return A string represented the MySQL code for the prepared statement.
     * @throws TranslationException If there is an error performing the
     *         translation.
     */

    public String translateIntoPreparedStatement(Expression expression) throws TranslationException
    {
	ExpressionPreparedStatementTranslatorMySQL translator = getTranslatorFor(expression.getType());
	return translator.translateExpression(expression);
    }

    /**
     * Gets the parameters to be used with the MySQL code generated by the
     * {@link translateIntoPreparedStatement} method.
     * 
     * @param expression The expression from which the parameters will be
     *        extracted.
     * @return A list of objects representing the prepared statement objects.
     * @throws TranslationException If there is an error performing the
     *         translation.
     */

    public List<Object> translateParametersForPreparedStatement(Expression expression) throws TranslationException
    {
	ExpressionPreparedStatementTranslatorMySQL translator = getTranslatorFor(expression.getType());
	return translator.translateParameters(expression);
    }

    /**
     * Auxiliary method that translates an error recovery expression modifying
     * the SQL code passed as parameter.
     */

    private void translateErrorRecoveryExpression(Expression errorRecoveryExpression, StringBuilder sqlCode)
	throws TranslationException
    {
	sqlCode.insert(0, "IFNULL(");
	sqlCode.append(",");
	sqlCode.append(translateIntoPreparedStatement(errorRecoveryExpression));
	sqlCode.append(")");
    }

    /**
     * Auxiliary method that gets all the prepared statement parameters (as a
     * list of objects) for the given expressions and error recovery expression.
     */

    private List<Object> getParametersForExpression(List<Expression> expressions, Expression errorRecoveryExpression)
	throws TranslationException
    {
	List<Object> parameters = new ArrayList<Object>();

	for(Expression currentExpression : expressions)
	    parameters.addAll(translateParametersForPreparedStatement(currentExpression));

	if(errorRecoveryExpression != null)
	    parameters.addAll(translateParametersForPreparedStatement(errorRecoveryExpression));

	return parameters;
    }

    /**
     * Gets the appropriate translator to be used with the given expression
     * type.
     */

    private ExpressionPreparedStatementTranslatorMySQL getTranslatorFor(ExpressionType type)
	throws TranslationException
    {
	switch(type)
	{
	    // Regular binary expressions.
	    case ADDITION:
	    case AND:
	    case DIFFERENCE:
	    case DIVISION:
	    case EQUAL:
	    case GREATER:
	    case GREATER_OR_EQUAL:
	    case LESS:
	    case LESS_OR_EQUAL:
	    case MULTIPLICATION:
	    case OR:
		return this.binaryTranslator;

		// Special cases for binary expressions.
	    case MATCHES_STRING:
	    case CONTAINS:
		return this.matchesStringTranslator;
	    case CONCATENATION:
		return this.concatenationTranslator;
	    case POWER:
		return this.powerTranslator;
	    case STARTS_WITH:
		return this.startsWithTranslator;

		// Special expressions.
	    case RANGE:
		return this.rangeTranslator;

		// Stats expressions.
	    case AVG:
	    case COUNT:
	    case MAX:
	    case MIN:
	    case MEDIAN:
	    case STDEV:
	    case SUM:
	    case VARIANCE:
		return this.statsTranslator;

		// Unary expressions.
	    case ABS:
	    case LOG:
	    case MINUS:
	    case LN:
	    case NOT:
	    case SQRT:
		return this.unaryTranslator;

		// Value expressions
	    case LITERAL:
		return this.literatlTranslator;
	    case REFERENCE:
		return this.referenceTranslator;
	    case VARIABLE:
		return this.variableTranslator;

	    default:
		throw new TranslationException("Unknown or not supported type: " + type);
	}
    }

    /**
     * Internal interface that represents a MySQL translator for CQL expressions
     * into MySQL prepared statements. Different implementations will be
     * provided based on the type of expression to be translated.
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private static interface ExpressionPreparedStatementTranslatorMySQL
    {
	/**
	 * Translates the given expression into the code of an equivalent MySQL
	 * prepared statement
	 */

	public String translateExpression(Expression expression) throws TranslationException;

	/**
	 * Translates the given expression into the list of parameters to be
	 * used with the equivalent MySQL prepared statement.
	 */
	public List<Object> translateParameters(Expression expression) throws TranslationException;
    }

    /**
     * Implementation for binary expressions (general case).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class BinaryExpressionTranslator implements ExpressionPreparedStatementTranslatorMySQL
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    ExpressionType expressionType = expression.getType();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 2)
		throw new TranslationException("Error translating " + expression + ", is not binary");

	    Expression expressionA = childExpressions.get(0);
	    Expression expressionB = childExpressions.get(1);

	    StringBuilder sql = new StringBuilder(128);
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionA));
	    sql.append(expressionType.getShortName());
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionB));

	    if(errorRecoveryExpression != null)
	    {
		ExpressionTranslatorMySQL.this.translateErrorRecoveryExpression(errorRecoveryExpression, sql);
		return sql.toString();
	    }
	    else
	    {
		sql.insert(0, "(").append(")");
		return sql.toString();
	    }
	}

	@Override
	public List<Object> translateParameters(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 2)
		throw new TranslationException("Error translating " + expression + ", is not binary");

	    return ExpressionTranslatorMySQL.this.getParametersForExpression(childExpressions, errorRecoveryExpression);
	}
    }

    /**
     * Implementation for unary expressions (special cases for array operators).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class UnaryExpressionTranslator implements ExpressionPreparedStatementTranslatorMySQL
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    ExpressionType expressionType = expression.getType();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 1)
		throw new TranslationException("Error translating " + expression + ", is not unary");

	    Expression childExpression = childExpressions.get(0);

	    StringBuilder sql = new StringBuilder(128);

	    // Special case for array operators
	    if(expressionType == ExpressionType.ARRAY_LENGTH)
		sql.append("(1)");

	    else if(expressionType == ExpressionType.ARRAY_ACCESS)
	    {
		ArrayAccessExpression accessExpression = ((ArrayAccessExpression) (expression));

		// We know we are NOT referencing an array (it would have been translated in 2 stages) 
		// and we are not accessing a literal (it would have been simplified).
		if(accessExpression.getAccessIndex() != 0)
		    throw new TranslationException("Error accessing an scalar with index != 0");
		else
		    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(childExpression));
	    }

	    // Regular case.
	    else
	    {
		sql.append(expressionType.getShortName()).append("(");
		sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(childExpression));
		sql.append(")");
	    }

	    if(errorRecoveryExpression != null)
	    {
		ExpressionTranslatorMySQL.this.translateErrorRecoveryExpression(errorRecoveryExpression, sql);
		return sql.toString();
	    }
	    else
		return sql.toString();
	}

	@Override
	public List<Object> translateParameters(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 1)
		throw new TranslationException("Error translating " + expression + ", is not unary");

	    return ExpressionTranslatorMySQL.this.getParametersForExpression(childExpressions, errorRecoveryExpression);
	}
    }

    /**
     * Implementation for stats expressions.
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class StatsExpressionTranslator implements ExpressionPreparedStatementTranslatorMySQL
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    StringBuilder sql = new StringBuilder(128);
	    sql.append(" ? ");

	    if(errorRecoveryExpression != null)
		ExpressionTranslatorMySQL.this.translateErrorRecoveryExpression(errorRecoveryExpression, sql);

	    return sql.toString();
	}

	@Override
	public List<Object> translateParameters(Expression expression) throws TranslationException
	{
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    try
	    {
		List<Object> parameters = new ArrayList<Object>(1);
		parameters.add(expression.calculateExpressionValue(null).getValueAsObject());

		if(errorRecoveryExpression != null)
		    parameters.addAll(ExpressionTranslatorMySQL.this.translateParametersForPreparedStatement(errorRecoveryExpression));

		return parameters;
	    }
	    catch(ExplorerCatCheckedException e)
	    {
		throw new TranslationException("Error translating stats function to SQL ", e);
	    }
	}
    }

    /**
     * Implementation for literal expressions (literal values).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class LiteralExpressionTranslator implements ExpressionPreparedStatementTranslatorMySQL
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    return "?";
	}

	@Override
	public List<Object> translateParameters(Expression expression) throws TranslationException
	{
	    try
	    {
		List<Object> parameters = new ArrayList<Object>(1);
		parameters.add(expression.calculateExpressionValue(null).getValueAsObject());
		return parameters;
	    }
	    catch(ExplorerCatCheckedException e)
	    {
		throw new TranslationException("Error translating literal expression: " + expression, e);
	    }
	}
    }

    /**
     * Implementation for expressions that represents user defined variables.
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class VariableExpressionTranslator implements ExpressionPreparedStatementTranslatorMySQL
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    // Does not have a recovery expression.
	    List<Expression> childExpressions = expression.getChildExpressions();

	    if(childExpressions.size() != 1)
		throw new TranslationException("Error translating " + expression + ", is not a variable");

	    Expression varDefinition = childExpressions.get(0);
	    return ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(varDefinition);
	}

	@Override
	public List<Object> translateParameters(Expression expression) throws TranslationException
	{
	    // Does not have a recovery expression.
	    List<Expression> childExpressions = expression.getChildExpressions();

	    if(childExpressions.size() != 1)
		throw new TranslationException("Error translating " + expression + ", it's not a variable");

	    return ExpressionTranslatorMySQL.this.getParametersForExpression(childExpressions, null);
	}
    }

    /**
     * Implementation for reference expressions (reference an entity property).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class ReferenceExpressionTranslator implements ExpressionPreparedStatementTranslatorMySQL
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    // Very ugly... but necessary.    
	    if(expression instanceof ReferenceExpression)
	    {
		String propertyName = ((ReferenceExpression) (expression)).getReferencedPropertyName();
		Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

		if(errorRecoveryExpression == null)
		    return propertyName;
		else
		{
		    String errorSQL = ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(errorRecoveryExpression);
		    return "IFNULL(" + propertyName + "," + errorSQL + ")";
		}
	    }
	    else
		throw new TranslationException("Error translating " + expression + ", it's not a reference");
	}

	@Override
	public List<Object> translateParameters(Expression expression) throws TranslationException
	{
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();
	    List<Object> parameters = new ArrayList<Object>();

	    if(errorRecoveryExpression != null)
		parameters.addAll(ExpressionTranslatorMySQL.this.translateParametersForPreparedStatement(errorRecoveryExpression));

	    return parameters;
	}
    }

    /**
     * Implementation for the range expression.
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class RangeExpressionTranslator implements ExpressionPreparedStatementTranslatorMySQL
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    // Very ugly... but necessary.    
	    if(expression instanceof RangeExpression)
	    {
		RangeExpression rangeExpression = ((RangeExpression) (expression));

		List<Expression> childExpressions = rangeExpression.getChildExpressions();
		Expression expressionToCheck = childExpressions.get(0);
		Expression startRangeExpression = childExpressions.get(1);
		Expression endRangeExpression = childExpressions.get(2);

		// Useless to add the error recovery expression.	
		return "(" + ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionToCheck)
		       + (rangeExpression.isRangeLeftClosed() ? " >= " : " > ")
		       + ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(startRangeExpression) + " AND "
		       + ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionToCheck)
		       + (rangeExpression.isRangeRightClosed() ? " <= " : " < ")
		       + ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(endRangeExpression) + ")";
	    }
	    else
		throw new TranslationException("Error translating " + expression + ", it is not a range expression");
	}

	@Override
	public List<Object> translateParameters(Expression expression) throws TranslationException
	{
	    // Note we don't add the parameters coming from the error recovery expression
	    // since we are not using it in range expressions. TODO Check this is true.
	    List<Expression> childExpressions = expression.getChildExpressions();
	    
	    // We have to replicate the first child expression (expression to check against the range)
	    // since the range expressions will be translated as: 
	    // (IFNULL(expressionToCheck,null) > NUM AND IFNULL(expressionToCheck,null) < NUM)
	    childExpressions.add(2, childExpressions.get(0));
	    	    
	    return ExpressionTranslatorMySQL.this.getParametersForExpression(childExpressions, null);
	}
    }

    /**
     * Implementation for the concatenation expression (special case of binary
     * expression).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class ConcatenationExpressionTranslator extends BinaryExpressionTranslator
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 2)
		throw new TranslationException("Error translating " + expression + ", it is not a concatenation");

	    Expression expressionA = childExpressions.get(0);
	    Expression expressionB = childExpressions.get(1);

	    StringBuilder sql = new StringBuilder(128);
	    sql.append("CONCAT(");
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionA));
	    sql.append(",");
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionB));
	    sql.append(")");

	    if(errorRecoveryExpression != null)
	    {
		ExpressionTranslatorMySQL.this.translateErrorRecoveryExpression(errorRecoveryExpression, sql);
		return sql.toString();
	    }
	    else
		return sql.toString();
	}
    }

    /**
     * Implementation for the matches string expression (special case of binary
     * expression).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class MatchesExpressionTranslator extends BinaryExpressionTranslator
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 2)
		throw new TranslationException("Error translating " + expression
					       + ", it is not a contains<string> expression");

	    Expression expressionA = childExpressions.get(0);
	    Expression expressionB = childExpressions.get(1);

	    StringBuilder sql = new StringBuilder(128);
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionA));
	    sql.append(" REGEXP \"");
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionB));
	    sql.append("\"");

	    if(errorRecoveryExpression != null)
	    {
		ExpressionTranslatorMySQL.this.translateErrorRecoveryExpression(errorRecoveryExpression, sql);
		return sql.toString();
	    }
	    else
	    {
		sql.insert(0, "(").append(")");
		return sql.toString();
	    }
	}
    }

    /**
     * Implementation for the power expression (special case of binary
     * expression).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class PowerExpressionTranslator extends BinaryExpressionTranslator
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 2)
		throw new TranslationException("Error translating " + expression + ", it is not a power expression");

	    Expression expressionA = childExpressions.get(0);
	    Expression expressionB = childExpressions.get(1);

	    StringBuilder sql = new StringBuilder(128);
	    sql.append("POWER(");
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionA));
	    sql.append(",");
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionB));
	    sql.append(")");

	    if(errorRecoveryExpression != null)
	    {
		ExpressionTranslatorMySQL.this.translateErrorRecoveryExpression(errorRecoveryExpression, sql);
		return sql.toString();
	    }
	    else
		return sql.toString();
	}
    }

    /**
     * Implementation for the starts with expression (special case of binary
     * expression).
     * 
     * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
     * @date 4 Mar 2011
     */

    private class StartsWithExpressionTranslatorMySQL extends BinaryExpressionTranslator
    {
	@Override
	public String translateExpression(Expression expression) throws TranslationException
	{
	    List<Expression> childExpressions = expression.getChildExpressions();
	    Expression errorRecoveryExpression = expression.getErrorRecoveryExpression();

	    if(childExpressions.size() != 2)
		throw new TranslationException("Error translating " + expression + ", it is not a power expression");

	    Expression expressionA = childExpressions.get(0);
	    Expression expressionB = childExpressions.get(1);

	    StringBuilder sql = new StringBuilder(128);
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionA));
	    sql.append(" LIKE CONCAT(");
	    sql.append(ExpressionTranslatorMySQL.this.translateIntoPreparedStatement(expressionB));
	    sql.append(",\"%\") ");

	    if(errorRecoveryExpression != null)
	    {
		ExpressionTranslatorMySQL.this.translateErrorRecoveryExpression(errorRecoveryExpression, sql);
		return sql.toString();
	    }
	    else
	    {
		sql.insert(0, "(").append(")");
		return sql.toString();
	    }
	}
    }

}
