package net.explorercat.cql.selection.query;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

import net.explorercat.cql.expressions.Expression;
import net.explorercat.cql.selection.Selection;
import net.explorercat.cql.selection.SelectionException;
import net.explorercat.cql.selection.limiters.Limiter;
import net.explorercat.cql.selection.sorters.EntitySorter;
import net.explorercat.util.exceptions.ExplorerCatCheckedException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Represents a query whose execution will generate a selection of entities (it
 * is the counterpart of the CQL selector block)
 * 
 * This class aggregates all the basics elements required to execute a query.
 * 
 * @author Jacob Almagro Garcia - jg10@sanger.ac.uk
 * @date July 2010
 */

public class Query
{
    // Logging
    private static final Log log = LogFactory.getLog(Query.class);

    // Label that identifies the CQL selector block that originates this query.
    private String queryLabel;

    private Map<String, Expression> variablesMap;
    private boolean areVariablesSimplified;

    private QueryCondition queryCondition;
    private Limiter resultingSelectionLimiter;
    private EntitySorter resultingSelectionSorter;

    // Text representation of the query.
    private String stringRepresentation;

    // The query will be executed against this selection 
    // (data will be selected from there).
    private Selection sourceSelection;

    // Unique identifier for the query. Must identify the query 
    // uniquely so any source/referenced selection has to be included.
    private String stringKey;

    /**
     * Builds a query providing all the required components.
     * 
     * @param label The label (name) of the query (the selection produced by the
     *        query will get the same name).
     * @param condition Query condition to be evaluated against the source
     *        selection.
     * @param sourceSelection The query will be executed against this selection.
     * @param variableMap Dictionary of user-defined variables used in the
     *        query.
     * @param sorter Object in charge of sorting the resulting selection.
     * @param limiter Object in charge of limiting the resulting selection (will
     *        discard entities).
     */

    public Query(String label, QueryCondition condition, Selection sourceSelection,
		 Map<String, Expression> variableMap, EntitySorter sorter, Limiter limiter)
    {
	this.queryLabel = label;
	this.sourceSelection = sourceSelection;
	this.queryCondition = condition;
	this.resultingSelectionSorter = sorter;
	this.resultingSelectionLimiter = limiter;
	this.variablesMap = variableMap;
	this.areVariablesSimplified = false;
	this.stringRepresentation = buildStringRepresentation();

	// Gets the key that will identify the query uniquely.
	this.stringKey = buildStringKey();
    }

    /**
     * Auxiliary method that generates a string that identifies the query
     * uniquely. This string will include the identifiers of any
     * source/referenced selection.
     * 
     * Format: [query][source] concatenated with [querySrc][sourceSrc]. Where
     * querySrc and sourceSrc are coming from the source selection (notice that
     * the source selection could have been generated by another query executed
     * against another selection). Any referenced selection will be inserted as
     * [query][source] as soon as it gets referenced in the query. Note we do
     * not include all the user defined variables, only the ones that are
     * accessed by the query condition.
     * 
     * @return A string that identifies the query uniquely.
     */

    private String buildStringKey()
    {
	StringBuilder StringBuilder = new StringBuilder(512);

	// First the query.
	StringBuilder.append("[" + queryCondition.getStringKey());

	// Variables
	StringBuilder.append("<");

	Iterator<Entry<String, Expression>> variableIterator = variablesMap.entrySet().iterator();
	while(variableIterator.hasNext())
	{
	    Entry<String, Expression> varEntry = variableIterator.next();
	    StringBuilder.append(varEntry.getKey()).append(":").append(varEntry.getValue().getStringKey()).append("|");
	}

	StringBuilder.append(">");

	// Limit
	if(resultingSelectionLimiter != null)
	    StringBuilder.append("," + resultingSelectionLimiter.getStringKey());

	// Sorter
	if(resultingSelectionSorter != null)
	    StringBuilder.append("," + resultingSelectionSorter.getStringKey());

	// Source selection.	
	StringBuilder.append("][" + sourceSelection.getSelectionLabel() + "]");
	StringBuilder.append(sourceSelection.getStringKey());

	return StringBuilder.toString();
    }

    /**
     * Gets the source selection to be used by the query. This method does NOT
     * provide a copy of the returning object so client code must not modify it.
     */

    public Selection getSourceSelection()
    {
	return sourceSelection;
    }

    /**
     * Sets the source selection that will be used by the query.
     * 
     * @param sourceSelection The selection that will be used to execute the
     *        query (entities will be selected from it).
     */

    public void setSourceSelection(Selection sourceSelection)
    {
	this.sourceSelection = sourceSelection;
    }

    /**
     * Gets the query label.
     */

    public String getLabel()
    {
	return queryLabel;
    }

    /**
     * Checks if the query contains user-defined variables.
     * 
     * @return True if at least one user-defined variable is used in the query.
     */

    public boolean hasVariables()
    {
	return !variablesMap.isEmpty();
    }

    /**
     * Gets the query condition to be evaluated against the selection. This
     * method does NOT provide a copy of the returning object so client code
     * must not modify it.
     */

    public QueryCondition getCondition()
    {
	return queryCondition;
    }

    /**
     * Gets the sorter that will be used to sort the entities of the resulting
     * selection after executing the query. This method does NOT provide a copy
     * of the returning object so client code must not modify it.
     * 
     * @return The sorter that will sort the resulting selection or null if
     *         there is none.
     */

    public EntitySorter getResultingSelectionSorter()
    {
	return resultingSelectionSorter;
    }

    /**
     * Gets the selection limiter that will be used with the resulting
     * selection. This method does NOT provide a copy of the returning object so
     * client code must not modify it.
     * 
     * @return The limiter to be used or null if there is none.
     */

    public Limiter getResultingSelectionLimiter()
    {
	return resultingSelectionLimiter;
    }

    /**
     * Gets a standard iterator that allows to iterate through all the
     * user-defined variables of the query in the form of entries (name,
     * expression).
     * 
     * @return An iterator that can iterate through all the user-defined
     *         variables of the query.
     */

    public Iterator<Entry<String, Expression>> getVariableIterator()
    {
	return variablesMap.entrySet().iterator();
    }

    /**
     * Executes the query against the source selection generating a new
     * selection of entities.
     * 
     * @return A new selection that contains the elements selected by the query.
     * @throws SelectionException If there is any problem performing the
     *         selection.
     */

    public Selection performSelection() throws SelectionException
    {
	return sourceSelection.selectEntities(this);
    }

    @Override
    public String toString()
    {
	return stringRepresentation;
    }

    /**
     * Auxiliary method that creates a string representation for the query. Do
     * not confuse this representation with the string key used for caching.
     * 
     * @return A textual human-friendly representation of the query.
     */

    private String buildStringRepresentation()
    {
	StringBuilder stringBuilder = new StringBuilder(512);

	stringBuilder.append("[").append(queryLabel != null ? queryLabel : "Unknown").append("]");
	stringBuilder.append("COND{").append(queryCondition != null ? queryCondition.toString() : "").append("}");

	if(resultingSelectionLimiter != null)
	    stringBuilder.append("LIMIT{").append(resultingSelectionLimiter.toString()).append("}");

	if(resultingSelectionSorter != null)
	    stringBuilder.append("SORT{").append(resultingSelectionSorter.toString()).append("}");

	return stringBuilder.toString();
    }

    /**
     * Gets a string that identifies the query uniquely. Any input/referenced
     * selection and the queries that generated them are included. This
     * identifier can be used as a key when caching queries. Notice this method
     * does NOT return the same result than the {@link toString} method.
     * 
     * @return A string that identifies uniquely the selection query.
     */

    public String getStringKey()
    {
	return stringKey;
    }

    /**
     * Tries to simplify the query condition.
     */

    public void simplifyCondition()
    {
	try
	{
	    this.queryCondition.simplify();
	}
	catch(ExplorerCatCheckedException e)
	{
	    log.error("Error simplifying the query condition, " + e);
	}
    }

    /**
     * Tries to simplify the variables defined by the user.
     */

    public void simplifyVariables()
    {
	if(!areVariablesSimplified)
	{
	    try
	    {
		Set<String> variableNames = this.variablesMap.keySet();

		for(String name : variableNames)
		    variablesMap.put(name, variablesMap.get(name).simplify());

		areVariablesSimplified = true;
	    }
	    catch(ExplorerCatCheckedException e)
	    {
		log.error("Error simplifying the query variables, " + e);
	    }
	}
    }

    /**
     * Tries to simplify the variables defined by the user and the query
     * condition.
     */

    public void simplify()
    {
	simplifyVariables();
	simplifyCondition();
    }
}
